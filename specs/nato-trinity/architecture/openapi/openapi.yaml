openapi: 3.0.3
info:
  title: NATO Trinity API
  version: 0.2.0
servers:
  - url: https://example.local
components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
  schemas:
    Problem:
      type: object
      required: [type, title, status]
      properties:
        type: { type: string, example: "about:blank" }
        title: { type: string }
        status: { type: integer }
        detail: { type: string }
        instance: { type: string }
        requestId: { type: string }
        errorCode: { type: string }

    EntityBase:
      type: object
      required: [id, version, createdAt, createdBy]
      properties:
        id: { type: string }
        version: { type: integer, minimum: 1 }
        createdAt: { type: string, format: date-time }
        createdBy: { type: string }
        updatedAt: { type: string, format: date-time }

    CreateRiskRequest:
      type: object
      required: [riskId, title, owner, likelihood, impact, score, status, dueDate]
      properties:
        riskId: { type: string }
        title: { type: string }
        description: { type: string }
        owner: { type: string }
        likelihood: { type: integer, minimum: 1, maximum: 5 }
        impact: { type: integer, minimum: 1, maximum: 5 }
        score: { type: integer, minimum: 1, maximum: 25 }
        status: { type: string, enum: [new, open, accepted, mitigated, closed] }
        dueDate: { type: string, format: date }
        controlRefs: { type: array, items: { type: string } }
        evidenceRefs: { type: array, items: { type: string } }
        caseRefs: { type: array, items: { type: string } }

    CreateDecisionRequest:
      oneOf:
        - type: object
          required: [decisionId, riskId, decisionType, rationale, approvedBy, approvedAt, expiryDate]
          properties:
            decisionId: { type: string }
            riskId: { type: string }
            decisionType: { type: string, enum: [treat, avoid, transfer, accept] }
            rationale: { type: string }
            approvedBy: { type: string }
            approvedAt: { type: string, format: date-time }
            expiryDate: { type: string, format: date }
            evidenceRefs: { type: array, items: { type: string } }
        - type: object
          required: [decisionId, riskId, decisionType, rationale, approvedBy, approvedAt]
          properties:
            decisionId: { type: string }
            riskId: { type: string }
            decisionType: { type: string, enum: [treat, avoid, transfer] }
            rationale: { type: string }
            approvedBy: { type: string }
            approvedAt: { type: string, format: date-time }
            evidenceRefs: { type: array, items: { type: string } }

    CreateExceptionRequest:
      type: object
      required: [exceptionId, requirementRef, scope, rationale, approvedBy, approvedAt, expiryDate]
      properties:
        exceptionId: { type: string }
        requirementRef: { type: string }
        scope: { type: string }
        rationale: { type: string }
        approvedBy: { type: string }
        approvedAt: { type: string, format: date-time }
        expiryDate: { type: string, format: date }

    IngestEvidenceRequest:
      type: object
      required: [evidenceId, evidenceType, sourceSystem, collectedAt, collectorId, hash, storageRef, retentionClass]
      properties:
        evidenceId: { type: string }
        evidenceType: { type: string, enum: [logExport, configSnapshot, ticket, report, sbom, vex, attestation, signature, screenshot] }
        sourceSystem: { type: string }
        collectedAt: { type: string, format: date-time }
        collectorId: { type: string }
        hash: { type: string }
        hashAlg: { type: string, default: sha256 }
        storageRef: { type: string }
        classification: { type: string, enum: [public, internal, sensitive] }
        retentionClass: { type: string, enum: [short, standard, long, legal] }
        metadata: { type: object, additionalProperties: true }

    CreateLegalHoldRequest:
      type: object
      required: [holdId, orgId, scopeRef, reason, status]
      properties:
        holdId: { type: string }
        orgId: { type: string }
        scopeRef: { type: string }
        reason: { type: string }
        status: { type: string, enum: [active] }

    GateResult:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, gateResultId, gateId, targetRef, status, executedAt]
          properties:
            type: { type: string, enum: [gateResult] }
            gateResultId: { type: string }
            gateId: { type: string }
            targetRef: { type: string }
            status: { type: string, enum: [pass, fail, warn] }
            executedAt: { type: string, format: date-time }
            evidenceRefs: { type: array, items: { type: string } }
            caseRef: { type: string }
            details: { type: object, additionalProperties: true }

    Evidence:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, evidenceId, evidenceType, sourceSystem, collectedAt, collectorId, hash, storageRef, retentionClass]
          properties:
            type: { type: string, enum: [evidence] }
            evidenceId: { type: string }
            evidenceType: { type: string, enum: [logExport, configSnapshot, ticket, report, sbom, vex, attestation, signature, screenshot] }
            sourceSystem: { type: string }
            collectedAt: { type: string, format: date-time }
            collectorId: { type: string }
            hash: { type: string }
            hashAlg: { type: string, default: sha256 }
            storageRef: { type: string }
            classification: { type: string, enum: [public, internal, sensitive] }
            retentionClass: { type: string, enum: [short, standard, long, legal] }
            metadata: { type: object, additionalProperties: true }

    Risk:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, riskId, title, owner, likelihood, impact, score, status, dueDate]
          properties:
            type: { type: string, enum: [risk] }
            riskId: { type: string }
            title: { type: string }
            description: { type: string }
            owner: { type: string }
            likelihood: { type: integer, minimum: 1, maximum: 5 }
            impact: { type: integer, minimum: 1, maximum: 5 }
            score: { type: integer, minimum: 1, maximum: 25 }
            status: { type: string, enum: [new, open, accepted, mitigated, closed] }
            dueDate: { type: string, format: date }
            controlRefs: { type: array, items: { type: string } }
            evidenceRefs: { type: array, items: { type: string } }
            caseRefs: { type: array, items: { type: string } }

    Decision:
      oneOf:
        - allOf:
            - $ref: '#/components/schemas/EntityBase'
            - type: object
              required: [type, decisionId, riskId, decisionType, rationale, approvedBy, approvedAt, expiryDate]
              properties:
                type: { type: string, enum: [decision] }
                decisionId: { type: string }
                riskId: { type: string }
                decisionType: { type: string, enum: [treat, avoid, transfer, accept] }
                rationale: { type: string }
                approvedBy: { type: string }
                approvedAt: { type: string, format: date-time }
                expiryDate: { type: string, format: date }
                evidenceRefs: { type: array, items: { type: string } }
        - allOf:
            - $ref: '#/components/schemas/EntityBase'
            - type: object
              required: [type, decisionId, riskId, decisionType, rationale, approvedBy, approvedAt]
              properties:
                type: { type: string, enum: [decision] }
                decisionId: { type: string }
                riskId: { type: string }
                decisionType: { type: string, enum: [treat, avoid, transfer] }
                rationale: { type: string }
                approvedBy: { type: string }
                approvedAt: { type: string, format: date-time }
                evidenceRefs: { type: array, items: { type: string } }

    Exception:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, exceptionId, requirementRef, scope, rationale, approvedBy, approvedAt, expiryDate]
          properties:
            type: { type: string, enum: [exception] }
            exceptionId: { type: string }
            requirementRef: { type: string }
            scope: { type: string }
            rationale: { type: string }
            approvedBy: { type: string }
            approvedAt: { type: string, format: date-time }
            expiryDate: { type: string, format: date }

    EvidencePackage:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, packageId, scopeRef, evidenceRefs, manifestHash, exportedAt, exportedBy]
          properties:
            type: { type: string, enum: [evidencePackage] }
            packageId: { type: string }
            scopeRef: { type: string }
            evidenceRefs: { type: array, items: { type: string } }
            manifestHash: { type: string }
            exportedAt: { type: string, format: date-time }
            exportedBy: { type: string }
            bundleRef: { type: string }

    LegalHold:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, holdId, orgId, scopeRef, reason, status]
          properties:
            type: { type: string, enum: [legalHold] }
            holdId: { type: string }
            orgId: { type: string }
            scopeRef: { type: string }
            reason: { type: string }
            status: { type: string, enum: [active, released] }

    AuditEvent:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, eventId, orgId, actor, action, objectRef, timestamp, outcome]
          properties:
            type: { type: string, enum: [auditEvent] }
            eventId: { type: string }
            orgId: { type: string }
            actor: { type: string }
            actorType: { type: string, enum: [human, service] }
            action: { type: string }
            objectRef: { type: string }
            timestamp: { type: string, format: date-time }
            outcome: { type: string, enum: [success, failure] }
            ip: { type: string }
            userAgent: { type: string }
            details: { type: object, additionalProperties: true }

    Case:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, caseId, severity, status, owner]
          properties:
            type: { type: string, enum: [case] }
            caseId: { type: string }
            severity: { type: string, enum: [low, medium, high, critical] }
            status: { type: string, enum: [new, triage, investigate, contain, eradicate, recover, closed] }
            owner: { type: string }
            triagedAt: { type: string, format: date-time }
            containedAt: { type: string, format: date-time }
            closedAt: { type: string, format: date-time }
            timelineRefs: { type: array, items: { type: string } }
            evidenceRefs: { type: array, items: { type: string } }
            riskRefs: { type: array, items: { type: string } }

    ChainOfCustodyEvent:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, eventId, evidenceId, action, timestamp, actor]
          properties:
            type: { type: string, enum: [chainOfCustodyEvent] }
            eventId: { type: string }
            evidenceId: { type: string }
            action: { type: string, enum: [collected, transferred, accessed, sealed, verified] }
            timestamp: { type: string, format: date-time }
            actor: { type: string }
            location: { type: string }
            details: { type: object, additionalProperties: true }

    Gate:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, gateId, name, status]
          properties:
            type: { type: string, enum: [gate] }
            gateId: { type: string }
            name: { type: string }
            description: { type: string }
            status: { type: string, enum: [active, disabled] }
            policyRef: { type: string }

    Manifest:
      type: object
      required: [manifestVersion, packageId, generatedAt, generatedBy, hashAlg, items]
      properties:
        manifestVersion: { type: string }
        packageId: { type: string }
        generatedAt: { type: string, format: date-time }
        generatedBy: { type: string }
        hashAlg: { type: string, enum: [sha256] }
        items:
          type: array
          items:
            type: object
            required: [evidenceId, hash, storageRef]
            properties:
              evidenceId: { type: string }
              hash: { type: string }
              storageRef: { type: string }
              evidenceType: { type: string }
              sourceSystem: { type: string }
              collectedAt: { type: string, format: date-time }
        signature:
          type: object
          properties:
            keyId: { type: string }
            alg: { type: string }
            value: { type: string }

    Playbook:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, playbookId, name, version]
          properties:
            type: { type: string, enum: [playbook] }
            playbookId: { type: string }
            name: { type: string }
            version: { type: integer, minimum: 1 }
            description: { type: string }
            trigger: { type: string }
            steps:
              type: array
              items:
                type: object
                properties:
                  stepId: { type: string }
                  action: { type: string }
                  params: { type: object, additionalProperties: true }

    ExecutionTrace:
      allOf:
        - $ref: '#/components/schemas/EntityBase'
        - type: object
          required: [type, traceId, status, startedAt]
          properties:
            type: { type: string, enum: [executionTrace] }
            traceId: { type: string }
            status: { type: string, enum: [running, success, failure] }
            startedAt: { type: string, format: date-time }
            endedAt: { type: string, format: date-time }
            requestId: { type: string }
            steps:
              type: array
              items:
                type: object
                properties:
                  stepId: { type: string }
                  status: { type: string }
                  startedAt: { type: string, format: date-time }
                  endedAt: { type: string, format: date-time }
                  logsRef: { type: string }

security:
  - bearerAuth: []
paths:
  /api/v1/risks:
    get:
      summary: List risks
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Risk'
    post:
      summary: Create risk
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateRiskRequest'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Risk'
  /api/v1/risks/{riskId}/decisions:
    post:
      summary: Create decision for a risk
      parameters:
        - name: riskId
          in: path
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateDecisionRequest'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Decision'
  /api/v1/exceptions:
    post:
      summary: Create exception
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateExceptionRequest'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Exception'
  /api/v1/gates/{gateId}/run:
    post:
      summary: Run a gate and produce GateResult
      parameters:
        - name: gateId
          in: path
          required: true
          schema:
            type: string
      responses:
        '202':
          description: Accepted
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GateResult'
        '400':
          description: Bad Request
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/gate-results/{gateResultId}:
    get:
      summary: Get GateResult
      parameters:
        - name: gateResultId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/GateResult'
        '404':
          description: Not Found
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/evidence:
    get:
      summary: List evidence
      parameters:
        - name: limit
          in: query
          schema: { type: integer, minimum: 1, maximum: 500, default: 100 }
        - name: after
          in: query
          schema: { type: string }
        - name: evidenceType
          in: query
          schema: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Evidence'
        '401':
          description: Unauthorized
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
    post:
      summary: Ingest evidence (collector)
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/IngestEvidenceRequest'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Evidence'
        '400':
          description: Bad Request
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/evidence/{evidenceId}:
    get:
      summary: Get evidence
      parameters:
        - name: evidenceId
          in: path
          required: true
          schema: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/Evidence'
        '404':
          description: Not Found
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/evidence/{evidenceId}/purge:
    post:
      summary: Purge evidence (controlled)
      description: Baseline requires Approver; regulated requires two-person + WORM constraints (ADR-0011).
      parameters:
        - name: evidenceId
          in: path
          required: true
          schema: { type: string }
      responses:
        '202':
          description: Accepted
        '400':
          description: Bad Request
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/evidence-packages:
    post:
      summary: Export an EvidencePackage
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [scopeRef]
              properties:
                scopeRef: { type: string }
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EvidencePackage'
        '400':
          description: Bad Request
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
        '401':
          description: Unauthorized
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
        '403':
          description: Forbidden
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
    get:
      summary: List evidence packages
      parameters:
        - name: limit
          in: query
          schema: { type: integer, minimum: 1, maximum: 500, default: 100 }
        - name: after
          in: query
          schema: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/EvidencePackage'
        '401':
          description: Unauthorized
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/evidence-packages/{packageId}:
    get:
      summary: Get evidence package
      parameters:
        - name: packageId
          in: path
          required: true
          schema:
            type: string
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/EvidencePackage'
        '404':
          description: Not Found
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/legal-holds/{holdId}:
    get:
      summary: Get legal hold
      parameters:
        - name: holdId
          in: path
          required: true
          schema: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LegalHold'
        '404':
          description: Not Found
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
  /api/v1/legal-holds:
    get:
      summary: List legal holds
      parameters:
        - name: limit
          in: query
          schema: { type: integer, minimum: 1, maximum: 500, default: 100 }
        - name: after
          in: query
          schema: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/LegalHold'
        '401':
          description: Unauthorized
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
    post:
      summary: Create legal hold
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateLegalHoldRequest'
      responses:
        '201':
          description: Created
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/LegalHold'
    patch:
      summary: Release legal hold
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required: [holdId, status]
              properties:
                holdId: { type: string }
                status: { type: string, enum: [released] }
      responses:
        '200':
          description: OK
  /api/v1/audit-events:
    get:
      summary: List audit events
      parameters:
        - name: limit
          in: query
          schema: { type: integer, minimum: 1, maximum: 500, default: 100 }
        - name: after
          in: query
          schema: { type: string }
        - name: actor
          in: query
          schema: { type: string }
        - name: action
          in: query
          schema: { type: string }
      responses:
        '200':
          description: OK
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/AuditEvent'
        '401':
          description: Unauthorized
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
        '403':
          description: Forbidden
          content:
            application/problem+json:
              schema:
                $ref: '#/components/schemas/Problem'
